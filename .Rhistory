tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i>burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin)))
}
mod <- sem.mcmc.w.inla(columbus)
ggplot(as.data.frame(rho), aes(x = V1)) +
geom_density()
ggplot(as.data.frame(mod$rho), aes(x = V1)) +
geom_density()
as.data.frame(mod$rho)
ggplot(data.frame(rho = mod$rho[-seq(500)]), aes(x = rho)) +
geom_density()
sem.mcmc.w.inla <- function(data){
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}else if (i>burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob,1))))
}
sem.mcmc.w.inla <- function(data){
browser()
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}else if (i>burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob,1))))
}
mod <- sem.mcmc.w.inla(columbus)
sem.mcmc.w.inla <- function(data){
browser()
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}else{
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob,1))))
}
mod <- sem.mcmc.w.inla(columbus)
View(tau)
intercept = intercept/(N-burnin)
mod <- sem.mcmc.w.inla(columbus)
return(list(intercept = intercept/(N-burnin)))
sem.mcmc.w.inla <- function(data){
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i > burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob,1))))
}
install.packages("raster")
sem.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i > burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob),1)))
}
sem.mcmc.w.inla <- function(data){
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i > burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob),1)))
}
mod <- sem.mcmc.w.inla(columbus)
sem.mcmc.w.inla <- function(data){
N = 100000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i > burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob),1)))
}
ggplot(as.data.frame(tau), aes(x = x, y = y)) +
geom_line()
ggplot(as.data.frame(mod$tau), aes(x = x, y = y)) +
geom_line()
ggplot(as.data.frame(mod$intercept), aes(x = x, y = y)) +
geom_line()
ggplot(as.data.frame(mod$INC), aes(x = x, y = y)) +
geom_line()
ggplot(as.data.frame(mod$HOVAL), aes(x = x, y = y)) +
geom_line()
ggplot(data.frame(rho = mod$rho), aes(x = rho)) +
geom_density()
save(mod, file = "sem-mcmc-w-inla.Rdata")
?source
source("missing.R")
save(mod, file = "sem-mcmc-w-inla.Rdata")
save(mod, file = "sem-mcmc-w-inla.Rdata")
exit
q()
source('~/.active-rstudio-document', echo=TRUE)
---
title: "Markov Chain Monte Carlo with Integrated Nested Laplace Approximations"
author: "Martin Outzen Berild"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
html_document:
toc: true
toc_depth: 2
toc_float: true
theme: united
---
<style>
.fluid-row{
width: 100%;
background: grey;
overflow-x: hidden;
margin: 0 -9999rem;
}
.title{
font-size: 25px;
}
.author{
font-size: 16px;
}
.date{
font-size: 16px
}
h1{
font-size: 20px;
font-weight: bold;
}
</style>
source('~/.active-rstudio-document', echo=TRUE)
install.packages("icon")
devtools::install_github("ropenscilabs/icon")
library(icon)
?ddoublex
library(smoothmest)#Laplace distribution
?ddoublex
1/0.071
1/0.73
library(INLA)
library(tidyverse)
library(ISLR)
library(glmnet)
library(smoothmest)#Laplace distribution
library(mvtnorm)
fit.inla <- function(data, b) {
data$oset <- data$x %*% matrix(b, ncol = 1)
res <- inla(y ~ -1 + offset(oset), data = data)
res <- inla.rerun(res)
return(list(mlik = res$mlik[[1]], alfa = res$marginals.fixed[[1]], tau = res$marginals.hyperpar[[1]]))
}
prior.beta <- function(x, mu = 0, lambda = 1/0.73, log = TRUE) {
res <- sum(log(ddoublex(x, mu = mu, lambda = lambda)))
if(!log) { res <- exp(res) }
return(res)
}
data(Hitters)
Hitters <- na.omit(Hitters)
x <- model.matrix(Salary ~ ., Hitters)[, -1]
x <- x[, 1:5]
y <- Hitters$Salary
y <- scale(y)
x <- scale(x)
d <- list(y = y, x = x)
n.beta <- ncol(d$x)
summary( fit.inla(d, b = rep(0, n.beta))$model )
x1 <-cbind(1,x)
ML.betas <- solve(t(x1)%*%x1)%*%t(x1)%*%y
ML.betas
stdev.samp <- .25 * solve(t(x)%*%x)
dq.beta <- function(x, y, sigma = stdev.samp, log =TRUE) {
dmvnorm(y, mean = x, sigma = sigma, log = log)
}
rq.beta <- function(x, sigma = stdev.samp) {
as.vector(rmvnorm(1, mean = x, sigma = sigma))
}
lasso.mcmc.w.inla <- function(data, n.beta){
N = 1000
burnin = 500
beta = matrix(data = NA,nrow = N, ncol = n.beta)
beta[1,] = rep(0,n.beta)
mod1 = fit.inla(data, beta[1,])
tau = mod1$tau * 0
pb <- txtProgressBar(min = 0, max = N, style = 3)
acc.prob = c()
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
beta[i,] = rq.beta(beta[i-1,])
mod2 = fit.inla(data,beta[i,])
acc.prob = c(acc.prob,
mod2$mlik +
prior.beta(beta[i,]) +
dq.beta(beta[i,],beta[i-1,]) -
mod1$mlik -
prior.beta(beta[i-1,]) -
dq.beta(beta[i-1,], beta[i,]))
if (log(runif(1))>acc.prob[i-1]){
beta[i,] = beta[i-1,]
if (i >burnin){
tau = tau + mod1$tau
}
}else if (i > burnin){
tau = tau + mod2$tau
}
}
return(list(beta = beta,
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob),1)))
}
set.seed(123)
mod = lasso.mcmc.w.inla(d, n.beta)
mean(mod$beta)
mean(mod$beta[1])
mean(mod$beta[,1])
mean(mod$beta[,2])
mean(mod$beta[,3])
mean(mod$beta[,4])
mean(mod$beta[,5])
beta = mod$beta
beta2 = beta[-seq(500),]
mean(beta2[,1])
mean(beta2[,2])
mean(beta2[,3])
mean(beta2[,4])
mean(beta2[,5])
?rgamma
dgamma(1,shape = 1,rate = 1/(5*10^(-5)))
dgamma(1,shape = 1,shape = (5*10^(-5)))
dgamma(1,shape = 1,scale = (5*10^(-5)))
dgamma(2,shape = 1,rate = 1/(5*10^(-5)))
dgamma(0.5,shape = 1,rate = 1/(5*10^(-5)))
dgamma(1000,shape = 1,rate = 1/(5*10^(-5)))
dgamma(100,shape = 1,rate = 1/(5*10^(-5)))
dgamma(100,shape = 1,scale = 100))
dgamma(100,shape = 1,scale = 100)
