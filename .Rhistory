acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
}
}else if (i>burnin){
}
}
return(list(rho=rho))
}
exit
browser()
browser(end)
sem.mcmc.w.inla <- function(data){
browser()
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
}
}else if (i>burnin){
}
}
return(list(rho=rho))
}
mod <- sem.mcmc.w.inla(columbus)
tmp = mod1$model
View(tmp)
tmp$marginals.fixed
tmp$marginals.fixed[1]
tmp$marginals.fixed[2]
tmp$marginals.fixed[3]
tmp$marginals.hyperpar
tmp$marginals.fixed[2]
tmp$marginals.hyperpar[[1]]
data(columbus)
lw <- nb2listw(col.gal.nb, style="W")
colsemml <- errorsarlm(CRIME ~ INC + HOVAL, data=columbus, lw, method="eigen",
quiet=FALSE)
W <- as(as_dgRMatrix_listw(nb2listw(col.gal.nb)), "CsparseMatrix")
columbus$idx<-1:nrow(columbus)
form<- CRIME ~ INC + HOVAL
zero.variance = list(prec=list(initial = 25, fixed=TRUE))
fit.inla <- function(data, rho) {
res <- sem.inla(form, d = data, W = W, rho = rho,
family = "gaussian", impacts = FALSE,
control.family = list(hyper = zero.variance),
verbose = FALSE)
return(list(mlik = res$mlik[[1]],
intercept = res$marginals.fixed[[1]],
INC = res$marginals.fixed[[2]],
HOVAL = res$marginals.fixed[[3]],
tau = res$marginals.hyperpar[[1]]))
}
dq.rho <- function(x, y, sigma = .15, log =TRUE) {
dnorm(y, mean = x, sd = sigma, log = log)
}
rq.rho <- function(x, sigma = .15) {
rnorm(1, mean = x, sd = sigma)
}
prior.rho <- function(x, log = TRUE) {
dunif(x, -1.5, 1, log = log)
}
sem.mcmc.w.inla <- function(data){
browser()
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i>burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin)))
}
mod <- sem.mcmc.w.inla(columbus)
sem.mcmc.w.inla <- function(data){
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i>burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin)))
}
mod <- sem.mcmc.w.inla(columbus)
ggplot(as.data.frame(rho), aes(x = V1)) +
geom_density()
ggplot(as.data.frame(mod$rho), aes(x = V1)) +
geom_density()
as.data.frame(mod$rho)
ggplot(data.frame(rho = mod$rho[-seq(500)]), aes(x = rho)) +
geom_density()
sem.mcmc.w.inla <- function(data){
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}else if (i>burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob,1))))
}
sem.mcmc.w.inla <- function(data){
browser()
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}else if (i>burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob,1))))
}
mod <- sem.mcmc.w.inla(columbus)
sem.mcmc.w.inla <- function(data){
browser()
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}else{
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob,1))))
}
mod <- sem.mcmc.w.inla(columbus)
View(tau)
intercept = intercept/(N-burnin)
mod <- sem.mcmc.w.inla(columbus)
return(list(intercept = intercept/(N-burnin)))
sem.mcmc.w.inla <- function(data){
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i > burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob,1))))
}
install.packages("raster")
sem.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i > burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob),1)))
}
sem.mcmc.w.inla <- function(data){
N = 1000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i > burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob),1)))
}
mod <- sem.mcmc.w.inla(columbus)
sem.mcmc.w.inla <- function(data){
N = 100000
burnin = 500
rho = c(0)
mod1 = fit.inla(data, rho[1])
intercept = mod1$intercept*0
INC = mod1$INC*0
HOVAL = mod1$HOVAL*0
tau = mod1$tau*0
acc.prob = c()
pb <- txtProgressBar(min = 0, max = N, style = 3)
for (i in seq(2,N)){
setTxtProgressBar(pb, i)
rho = c(rho,rq.rho(rho[i-1]))
mod2 = fit.inla(data,rho[i])
acc.prob = c(acc.prob,
mod2$mlik +
prior.rho(rho[i]) +
dq.rho(rho[i],rho[i-1]) -
mod1$mlik -
prior.rho(rho[i-1]) -
dq.rho(rho[i-1], rho[i]))
if (log(runif(1))>acc.prob[i-1]){
rho[i] = rho[i-1]
if (i > burnin){
intercept = intercept + mod1$intercept
INC = INC + mod1$INC
HOVAL = HOVAL + mod1$HOVAL
tau = tau + mod1$tau
}
}else if (i > burnin){
intercept = intercept + mod2$intercept
INC = INC + mod2$INC
HOVAL = HOVAL + mod2$HOVAL
tau = tau + mod2$tau
}
}
return(list(rho=rho,
intercept = intercept/(N-burnin),
INC = INC/(N-burnin),
HOVAL = HOVAL/(N-burnin),
tau = tau/(N-burnin),
acc.prob = min(exp(acc.prob),1)))
}
ggplot(as.data.frame(tau), aes(x = x, y = y)) +
geom_line()
ggplot(as.data.frame(mod$tau), aes(x = x, y = y)) +
geom_line()
ggplot(as.data.frame(mod$intercept), aes(x = x, y = y)) +
geom_line()
ggplot(as.data.frame(mod$INC), aes(x = x, y = y)) +
geom_line()
ggplot(as.data.frame(mod$HOVAL), aes(x = x, y = y)) +
geom_line()
ggplot(data.frame(rho = mod$rho), aes(x = rho)) +
geom_density()
save(mod, file = "sem-mcmc-w-inla.Rdata")
?source
source("missing.R")
save(mod, file = "sem-mcmc-w-inla.Rdata")
save(mod, file = "sem-mcmc-w-inla.Rdata")
exit
q()
