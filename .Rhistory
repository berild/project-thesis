beta = beta,
tau = tau/(N-burnin),
acc.prob = sapply(exp(acc.prob),min,1)))
}
set.seed(123)
df = sample.linreg()
mod = linreg.mcmc.w.inla(df)
fit.inla <- function(data,b){
res = inla(y ~1+offset( b[1] * x1) + offset(b[2]*x2), data = data)
return(list(mlik = res$mlik[1,1], alfa = res$marginals.fixed[[1]], tau = res$marginals.hyperpar[[1]]))
}
sample.linreg <- function(){
n = 100
x1 = runif(n)
x2 = runif(n)
err = rnorm(n)
y = 3 + 2*x1 -2*x2
df = data.frame(y = y, x1 = x1, x2 = x2)
}
linreg.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
beta = matrix(data = NA,nrow = nrow(data), ncol = 2)
colnames(beta) = colnames(data[,-1])
beta[1,] = c(0,0)
mod1 = fit.inla(data,beta[1,])
alfa = mod1$alfa*0
tau = mod1$tau * 0
pb <- txtProgressBar(min = 0, max = N, style = 3)
acc.prob = c()
for (i in seq(2, N)){
setTxtProgressBar(pb, i)
beta[i,] = draw.prop.beta(beta[i-1,])
mod2 = fit.inla(data,beta[i,])
acc.prob = c(acc.prob,
mod2$mlik +
prior.beta(beta[i,]) +
prob.prop.beta(beta[i-1,],beta[i,]) -
mod1$mlik -
prior.beta(beta[i-1,]) -
prob.prop.beta(beta[i,], beta[i-1,]))
if (log(runif(1))>=acc.prob[i-1]){
beta[i,] = beta[i-1,]
}else{
mod1 = mod2
}
if (i > burnin){
alfa = alfa + mod1$alfa
tau = tau + mod1$tau
}
}
return(list(alfa = alfa/(N-burnin),
beta = beta,
tau = tau/(N-burnin),
acc.prob = sapply(exp(acc.prob),min,1)))
}
set.seed(123)
df = sample.linreg()
mod = linreg.mcmc.w.inla(df)
fit.inla <- function(data,b){
data$oset = b[1] * data$x1 + b[2]*data$x2
res = inla(y ~1+offset(oset), data = data)
return(list(mlik = res$mlik[1,1], alfa = res$marginals.fixed[[1]], tau = res$marginals.hyperpar[[1]]))
}
linreg.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
beta = matrix(data = NA,nrow = nrow(data), ncol = 2)
colnames(beta) = colnames(data[,-1])
beta[1,] = c(0,0)
mod1 = fit.inla(data,beta[1,])
alfa = mod1$alfa*0
tau = mod1$tau * 0
pb <- txtProgressBar(min = 0, max = N, style = 3)
acc.prob = c()
for (i in seq(2, N)){
setTxtProgressBar(pb, i)
beta[i,] = draw.prop.beta(beta[i-1,])
mod2 = fit.inla(data,beta[i,])
acc.prob = c(acc.prob,
mod2$mlik +
prior.beta(beta[i,]) +
prob.prop.beta(beta[i-1,],beta[i,]) -
mod1$mlik -
prior.beta(beta[i-1,]) -
prob.prop.beta(beta[i,], beta[i-1,]))
if (log(runif(1))>=acc.prob[i-1]){
beta[i,] = beta[i-1,]
}else{
mod1 = mod2
}
if (i > burnin){
alfa = alfa + mod1$alfa
tau = tau + mod1$tau
}
}
return(list(alfa = alfa/(N-burnin),
beta = beta,
tau = tau/(N-burnin),
acc.prob = sapply(exp(acc.prob),min,1)))
}
set.seed(123)
df = sample.linreg()
mod = linreg.mcmc.w.inla(df)
mod_inla = inla(y~1 + x1 + x2,df)
mod_inla = inla(y~1 + x1 + x2,data = df)
View(mod_inla)
View(mod.inla)
mod_inla = inla(y~1 + x1 + x2,data = df)
library(INLA)
library(tidyverse)
draw.prop.beta <- function(b,sigma = 1/0.75){
rnorm(length(b),mean = b, sd = sigma)
}
prob.prop.beta <- function(b1,b2, sigma = 1/0.75, log = TRUE){
sum(dnorm(b1,mean = b2, sd = sigma, log = log))
}
prior.beta <- function(b, sigma = sqrt(1/.001), log = TRUE) {
sum(dnorm(b, mean = 0, sd= sigma, log = log))
}
fit.inla <- function(data,b){
data$oset = b[1] * data$x1 + b[2]*data$x2
res = inla(y ~1+offset(oset), data = data)
return(list(mlik = res$mlik[1,1],
alfa = res$marginals.fixed[[1]],
tau = res$marginals.hyperpar[[1]]))
}
sample.linreg <- function(){
n = 100
x1 = runif(n)
x2 = runif(n)
err = rnorm(n)
y = 3 + 2*x1 -2*x2
df = data.frame(y = y, x1 = x1, x2 = x2)
}
linreg.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
beta = matrix(data = NA,nrow = nrow(data), ncol = 2)
colnames(beta) = colnames(data[,-1])
beta[1,] = c(0,0)
mod1 = fit.inla(data,beta[1,])
alfa = mod1$alfa*0
tau = mod1$tau * 0
pb <- txtProgressBar(min = 0, max = N, style = 3)
acc.prob = c()
for (i in seq(2, N)){
setTxtProgressBar(pb, i)
beta[i,] = draw.prop.beta(beta[i-1,])
mod2 = fit.inla(data,beta[i,])
acc.prob = c(acc.prob,
mod2$mlik +
prior.beta(beta[i,]) +
prob.prop.beta(beta[i-1,],beta[i,]) -
mod1$mlik -
prior.beta(beta[i-1,]) -
prob.prop.beta(beta[i,], beta[i-1,]))
if (log(runif(1))>=acc.prob[i-1]){
beta[i,] = beta[i-1,]
}else{
mod1 = mod2
}
if (i > burnin){
alfa = alfa + mod1$alfa
tau = tau + mod1$tau
}
}
return(list(alfa = alfa/(N-burnin),
beta = beta,
tau = tau/(N-burnin),
acc.prob = sapply(exp(acc.prob),min,1)))
}
set.seed(123)
df = sample.linreg()
mod = linreg.mcmc.w.inla(df)
linreg.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
beta = matrix(data = NA,nrow = N, ncol = 2)
colnames(beta) = colnames(data[,-1])
beta[1,] = c(0,0)
mod1 = fit.inla(data,beta[1,])
alfa = mod1$alfa*0
tau = mod1$tau * 0
pb <- txtProgressBar(min = 0, max = N, style = 3)
acc.prob = c()
for (i in seq(2, N)){
setTxtProgressBar(pb, i)
beta[i,] = draw.prop.beta(beta[i-1,])
mod2 = fit.inla(data,beta[i,])
acc.prob = c(acc.prob,
mod2$mlik +
prior.beta(beta[i,]) +
prob.prop.beta(beta[i-1,],beta[i,]) -
mod1$mlik -
prior.beta(beta[i-1,]) -
prob.prop.beta(beta[i,], beta[i-1,]))
if (log(runif(1))>=acc.prob[i-1]){
beta[i,] = beta[i-1,]
}else{
mod1 = mod2
}
if (i > burnin){
alfa = alfa + mod1$alfa
tau = tau + mod1$tau
}
}
return(list(alfa = alfa/(N-burnin),
beta = beta,
tau = tau/(N-burnin),
acc.prob = sapply(exp(acc.prob),min,1)))
}
load("/home/shomed/m/martinob/Documents/host2019/project/project-thesis/linreg/linreg.Rdata")
# McMC with INLA results
tau = as.data.frame(mod$tau)
alfa = as.data.frame(mod$alfa)
res = cbind(data.frame(step = seq(nrow(mod$beta)), acc.prob = mod$acc.prob),as.data.frame(mod$beta))
acc.prob = c(0,mod$acc.prob)
res = cbind(data.frame(step = seq(nrow(mod$beta)), acc.prob = acc.prob),as.data.frame(mod$beta))
res$is_burnin = c(rep(T,500),rep(F,nrow(res)-500))
ggplot(res) +
geom_line(aes(x = step, y = acc.prob))
View(res)
View(res)
View(res)
params = colnames(res[,-c(1,2,ncol(res))])
means = data.frame(key = params,
value = c(sapply(res[,params],mean)))
res = gather(res,key,value,params)
traceplot <- ggplot(res, aes(x = step, y = value, color = is_burnin)) +
geom_line() +
facet_wrap(vars(key),scales="free",ncol = 2)
traceplot
distplot <- ggplot(res[res$is_burnin==F,]) +
geom_density(aes(x = value),fill = "deepskyblue" , alpha = 0.5) +
geom_vline(data = means,aes(xintercept = value),color = "firebrick") +
geom_text(data = means,aes(label = sprintf("%.3f",value), x = value),
y = 0.2, size = 6,color = "firebrick") +
facet_wrap(vars(key),scales="free",ncol = 2)
distplot <- ggplot(res[res$is_burnin==F,]) +
geom_density(aes(x = value),fill = "deepskyblue" , alpha = 0.5) +
geom_vline(data = means,aes(xintercept = value),color = "firebrick") +
geom_text(data = means,aes(label = sprintf("%.3f",value), x = value),
y = 0.2, size = 6,color = "firebrick") +
facet_wrap(vars(key),scales="free",ncol = 2)
distplot
load("~/Documents/host2019/project/project-thesis/lasso/lasso-mcmc-w-inla.Rdata")
load("~/Documents/host2019/project/project-thesis/lasso/lasso-mcmc-w-inla.Rdata")
# McMC with INLA results
tau = as.data.frame(mod$tau)
acc.prob = c(0,mod$acc.prob)
res = cbind(data.frame(step = seq(nrow(mod$beta)), acc.prob = acc.prob),as.data.frame(mod$beta))
res$is_burnin = c(rep(T,500),rep(F,nrow(res)-500))
ggplot(res) +
geom_line(aes(x = step, y = acc.prob))
mean(res$acc.prob)
params = colnames(res[,-c(1,2,ncol(res))])
means = data.frame(key = params,
value = c(sapply(res[,params],mean)))
res = gather(res,key,value,params)
traceplot <- ggplot(res, aes(x = step, y = value, color = is_burnin)) +
geom_line() +
facet_wrap(vars(key),scales="free",ncol = 2)
traceplot
distplot <- ggplot(res[res$is_burnin==F,]) +
geom_density(aes(x = value),fill = "deepskyblue" , alpha = 0.5) +
geom_vline(data = means,aes(xintercept = value),color = "firebrick") +
geom_text(data = means,aes(label = sprintf("%.3f",value), x = value),
y = 0.2, size = 6,color = "firebrick") +
facet_wrap(vars(key),scales="free",ncol = 2)
distplot
traceplot
distplot
ggplot(tau) +
geom_line(aes(x= x, y = y))
# INLA restults
load(file = "./linreg/linreg_INLA.Rdata")
# INLA restults
load(file = "./linreg/linreg_INLA.Rdata")
View(mod_inla)
mod_inla$marginals.fixed
beta_1 = as.data.frame(mod_inla$marginals.fixed[[2]])
beta_2 = as.data.frame(mod_inla$marginals.fixed[[3]])
beta_0 = as.data.frame(mod_inla$marginals.fixed[[1]])
mod_inla$marginals.hyperpar
tau = as.data.frame(mod_inla$marginals.hyperpar[[1]])
rm(mod_inla)
res = rbind(
cbind(key = rep("beta_0",nrow(beta_0)),beta_0),
cbind(key = rep("beta_1",nrow(beta_1)),beta_1),
cbind(key = rep("beta_2",nrow(beta_2)),beta_2),
cbind(key = rep("tau",nrow(tau)),tau)
)
rm(mod_inla)
inla_dens <- ggplot(res, aes(x = x, y = y)) +
geom_line(color = "deepskyblue") +
facet_wrap(.~key, scales = "free", ncol = 2)
inla_dens
inla_dens <- ggplot(res, aes(x = x, y = y)) +
geom_line(color = "deepskyblue") +
facet_wrap(.~key, scales = "free", ncol = 2) +
theme_classic()
inla_dens
library(INLA)
library(tidyverse)
draw.prop.beta <- function(b){
rnorm(length(b),mean = b, sd = 1/0.75)
}
prob.prop.beta <- function(b1,b2){
}
prior.beta <- function(b) {
sum(dnorm(b, mean = 0, sd= sqrt(1/.001), log = TRUE))
}
fit.inla <- function(data,b){
data$oset = b[1] * data$x1 + b[2]*data$x2
res = inla(y ~1+offset(oset), data = data)
return(list(mlik = res$mlik[1,1],
alfa = res$marginals.fixed[[1]],
tau = res$marginals.hyperpar[[1]]))
}
sample.linreg <- function(){
n = 100
x1 = runif(n)
x2 = runif(n)
err = rnorm(n)
y = 3 + 2*x1 -2*x2
df = data.frame(y = y, x1 = x1, x2 = x2)
}
linreg.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
beta = matrix(data = NA,nrow = N, ncol = 2)
colnames(beta) = colnames(data[,-1])
beta[1,] = c(0,0)
mod1 = fit.inla(data,beta[1,])
alfa = mod1$alfa*0
tau = mod1$tau * 0
pb <- txtProgressBar(min = 0, max = N, style = 3)
acc.prob = c(0)
for (i in seq(2, N)){
setTxtProgressBar(pb, i)
beta[i,] = draw.prop.beta(beta[i-1,])
mod2 = fit.inla(data,beta[i,])
acc.prob = c(acc.prob,
mod2$mlik +
prior.beta(beta[i,]) +
prob.prop.beta(beta[i-1,],beta[i,]) -
mod1$mlik -
prior.beta(beta[i-1,]) -
prob.prop.beta(beta[i,], beta[i-1,]))
if (log(runif(1))>=acc.prob[i]){
beta[i,] = beta[i-1,]
}else{
mod1 = mod2
}
if (i > burnin){
alfa = alfa + mod1$alfa
tau = tau + mod1$tau
}
}
return(list(alfa = alfa/(N-burnin),
beta = beta,
tau = tau/(N-burnin),
acc.prob = sapply(exp(acc.prob),min,1)))
}
set.seed(123)
df = sample.linreg()
mod = linreg.mcmc.w.inla(df)
linreg.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
beta = matrix(data = NA,nrow = N, ncol = 2)
colnames(beta) = colnames(data[,-1])
beta[1,] = c(0,0)
mod1 = fit.inla(data,beta[1,])
alfa = mod1$alfa*0
tau = mod1$tau * 0
pb <- txtProgressBar(min = 0, max = N, style = 3)
browser()
acc.prob = c(0)
for (i in seq(2, N)){
setTxtProgressBar(pb, i)
beta[i,] = draw.prop.beta(beta[i-1,])
mod2 = fit.inla(data,beta[i,])
acc.prob = c(acc.prob,
mod2$mlik +
prior.beta(beta[i,]) +
prob.prop.beta(beta[i-1,],beta[i,]) -
mod1$mlik -
prior.beta(beta[i-1,]) -
prob.prop.beta(beta[i,], beta[i-1,]))
if (log(runif(1))>=acc.prob[i]){
beta[i,] = beta[i-1,]
}else{
mod1 = mod2
}
if (i > burnin){
alfa = alfa + mod1$alfa
tau = tau + mod1$tau
}
}
return(list(alfa = alfa/(N-burnin),
beta = beta,
tau = tau/(N-burnin),
acc.prob = sapply(exp(acc.prob),min,1)))
}
set.seed(123)
df = sample.linreg()
library(INLA)
library(tidyverse)
draw.prop.beta <- function(b){
rnorm(length(b),mean = b, sd = 1/0.75)
}
prob.prop.beta <- function(b1,b2){
sum(dnorm(b1,mean = b2, sd = 1/0.75, log = TRUE))
}
prior.beta <- function(b) {
sum(dnorm(b, mean = 0, sd= sqrt(1/.001), log = TRUE))
}
fit.inla <- function(data,b){
data$oset = b[1] * data$x1 + b[2]*data$x2
res = inla(y ~1+offset(oset), data = data)
return(list(mlik = res$mlik[1,1],
alfa = res$marginals.fixed[[1]],
tau = res$marginals.hyperpar[[1]]))
}
sample.linreg <- function(){
n = 100
x1 = runif(n)
x2 = runif(n)
err = rnorm(n)
y = 3 + 2*x1 -2*x2
df = data.frame(y = y, x1 = x1, x2 = x2)
}
linreg.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
beta = matrix(data = NA,nrow = N, ncol = 2)
colnames(beta) = colnames(data[,-1])
beta[1,] = c(0,0)
mod1 = fit.inla(data,beta[1,])
alfa = mod1$alfa*0
tau = mod1$tau * 0
pb <- txtProgressBar(min = 0, max = N, style = 3)
browser()
acc.prob = c(0)
for (i in seq(2, N)){
setTxtProgressBar(pb, i)
beta[i,] = draw.prop.beta(beta[i-1,])
mod2 = fit.inla(data,beta[i,])
acc.prob = c(acc.prob,
mod2$mlik +
prior.beta(beta[i,]) +
prob.prop.beta(beta[i-1,],beta[i,]) -
mod1$mlik -
prior.beta(beta[i-1,]) -
prob.prop.beta(beta[i,], beta[i-1,]))
if (log(runif(1))>=acc.prob[i]){
beta[i,] = beta[i-1,]
}else{
mod1 = mod2
}
if (i > burnin){
alfa = alfa + mod1$alfa
tau = tau + mod1$tau
}
}
return(list(alfa = alfa/(N-burnin),
beta = beta,
tau = tau/(N-burnin),
acc.prob = sapply(exp(acc.prob),min,1)))
}
set.seed(123)
df = sample.linreg()
mod = linreg.mcmc.w.inla(df)
linreg.mcmc.w.inla <- function(data){
N = 10000
burnin = 500
beta = matrix(data = NA,nrow = N, ncol = 2)
colnames(beta) = colnames(data[,-1])
beta[1,] = c(0,0)
mod1 = fit.inla(data,beta[1,])
alfa = mod1$alfa*0
tau = mod1$tau * 0
pb <- txtProgressBar(min = 0, max = N, style = 3)
acc.prob = c(0)
for (i in seq(2, N)){
setTxtProgressBar(pb, i)
beta[i,] = draw.prop.beta(beta[i-1,])
mod2 = fit.inla(data,beta[i,])
acc.prob = c(acc.prob,
mod2$mlik +
prior.beta(beta[i,]) +
prob.prop.beta(beta[i-1,],beta[i,]) -
mod1$mlik -
prior.beta(beta[i-1,]) -
prob.prop.beta(beta[i,], beta[i-1,]))
if (log(runif(1))>=acc.prob[i]){
beta[i,] = beta[i-1,]
}else{
mod1 = mod2
}
if (i > burnin){
alfa = alfa + mod1$alfa
tau = tau + mod1$tau
}
}
return(list(alfa = alfa/(N-burnin),
beta = beta,
tau = tau/(N-burnin),
acc.prob = sapply(exp(acc.prob),min,1)))
}
